From PNG 1.2 specification:

This table summarizes some properties of the standard chunk types.

Critical chunks (must appear in this order, except PLTE
                 is optional):

        Name  Multiple  Ordering constraints
                OK?

        IHDR    No      Must be first
        PLTE    No      Before IDAT
        IDAT    Yes     Multiple IDATs must be consecutive
        IEND    No      Must be last

Ancillary chunks (need not appear in this order):

        Name  Multiple  Ordering constraints
                OK?

        cHRM    No      Before PLTE and IDAT
        gAMA    No      Before PLTE and IDAT
        iCCP    No      Before PLTE and IDAT
        sBIT    No      Before PLTE and IDAT
        sRGB    No      Before PLTE and IDAT
        bKGD    No      After PLTE; before IDAT
        hIST    No      After PLTE; before IDAT
        tRNS    No      After PLTE; before IDAT
        pHYs    No      Before IDAT
        sPLT    Yes     Before IDAT
        tIME    No      None
        iTXt    Yes     None
        tEXt    Yes     None
        zTXt    Yes     None

The PNG chunk code alphabet is the set of strings comprising of exactly four
uppercase or lowercase ASCII letters: (a-zA-Z){4}

png_regular_expression =
    "IHDR"
    (BEFORE_PALETTE|BEFORE_DATA|ALLOWED_ANYWHERE|UNKNOWN) *
    "PLTE" ? 
    (AFTER_PALETTE_BEFORE_DATA|BEFORE_DATA|ALLOWED_ANYWHERE|UNKNOWN) *
    "IDAT" +
    (ALLOWED_ANYWHERE|UNKNOWN) *
    "IEND"


This does not handle the uniqueness constraints in the ancillary chunks.
More research is necessary before I can figure out which formal language
class describes sequences of PNG chunk codes. For brevity, I will now refer
to the language of all valid PNG chunk code sequences as PNGCHKLANG.


While PNGCHKLANG has a very large alphabet (N = 4 ^ 52 ~= 2.03e31), only 18
of the letters (the 18 standard type codes) are important. The remaining
letters are semantically quite trivial, since they can appear anywhere
in a PNGCHKLANG word except initially and terminally. PNGCHKLANG is therefore
somewhat isomorphic to a language which is simpler to work with, one with
only 19 letters. I will call this language reduced-PNGCHKLANG, or RCHKLANG.


RCHKLANG informally:

Critical chunks (must appear in this order, except PLTE is optional):

    Letter  Mnemonic  Chunk  Multiple  Ordering constraints
                      Code   OK?
   
      H     header    IHDR   No        Must be first
      P     palette   PLTE   No        Before IDAT
      D     data      IDAT   Yes       Multiple IDATs must be consecutive
      E     end       IEND   No        Must be last

Ancillary chunks (need not appear in this order, and none are required):

    Letter  Mnemonic  Chunk  Multiple  Ordering constraints
                      Code   OK?
   
      c     chroma    cHRM   No        Before PLTE and IDAT
      g     gamma     gAMA   No        Before PLTE and IDAT
      e     embed     iCCP   No        Before PLTE and IDAT
      s     signifi.  sBIT   No        Before PLTE and IDAT
      r     red       sRGB   No        Before PLTE and IDAT
      b     backgro.  bKGD   No        After PLTE; before IDAT
      h     histogr.  hIST   No        After PLTE; before IDAT
      t     transpa.  tRNS   No        After PLTE; before IDAT
      d     dimensi.  pHYs   No        Before IDAT
      p     palette   sPLT   Yes       Before IDAT
      m     minute    tIME   No        None
      u     unicode   iTXt   Yes       None
      w     words     tEXt   Yes       None
      z     zipped    zTXt   Yes       None

U (unknown) represents any character besides those defined above:

      U     unknown          Yes       None  


The reduced alphabet is {H,P,D,E,c,g,e,s,r,b,h,t,d,p,m,u,w,z,U}.

Some examples of words in this language:

    HDE (smallest possible word)
    HPDE

With all "known" letters:

    HcgesrPbhtdpDmuwzE

Demonstrating that some chunks can occur multiple times in discrete places:

    HuPuDuE

Demonstrating uniqueness constraint: HmPDE, HPmDE, and HPDmE are words in
RCHKLANG, but HmPmDE, HPmDmE, and HmPmDmE are not in the language because
'm' (tIME) is allowed to appear at most once.


My intuition tells me that RCHKLANG is not a regular language, because of the
uniqueness constraints that must be checked across the entire word. I have a
weaker feeling that RCHKLANG is not a context-free language. I will attempt to
prove the former first.


Pumping Lemma for Regular Languages (from Wikipedia):

    Let L be a regular language. Then there exists an integer p >= 1 depending
    only on L such that every string w in L of length at least p (p is called
    the "pumping length") can be written as w = xyz (i.e., w can be divided
    into three substrings), satisfying the following conditions:

        1. |y| >= 1
        2. |xy| <= p
        3. for all i >= 0, x(y^i)z is an element of L

    y is the substring that can be pumped (removed or repeated any number of
    times, and the resulting string is always in L). (1) means the loop y to
    be pumped must be of length at least one; (2) means the loop must occur
    within the first p characters. |x| must be smaller than p (conclusion of
    (1) and (2)), apart from that there is no restriction on x and z.  

    In simple words, for any regular language L, any sufficiently long word
    w (in L) can be split into 3 parts. i.e. w = xyz , such that all the
    strings x(y^k)z for k >= 0 are also in L.


Let L = RCHKLANG, w = xyz = HPDE, x = H, y = PD, z = E.
Since x(y^2)z = HPDPDE is not in L, L is not regular.

This is not necessarily valid...











